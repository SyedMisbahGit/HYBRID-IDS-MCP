# Logstash Pipeline for Network Flow Features
# Processes extracted ML features (78 features per flow) for analysis

input {
  # Read features from CSV file
  file {
    path => "/var/log/hybrid-ids/features.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "network_features"
    tags => ["features", "ml", "flows"]
  }
}

filter {
  if [type] == "network_features" {
    # Parse CSV (first line is header)
    csv {
      separator => ","
      columns => [
        "duration", "total_fwd_packets", "total_bwd_packets", "total_fwd_bytes", "total_bwd_bytes",
        "fwd_pkt_len_max", "fwd_pkt_len_min", "fwd_pkt_len_mean", "fwd_pkt_len_std",
        "bwd_pkt_len_max", "bwd_pkt_len_min", "bwd_pkt_len_mean", "bwd_pkt_len_std",
        "flow_bytes_per_sec", "flow_packets_per_sec", "flow_iat_mean", "flow_iat_std", "flow_iat_max", "flow_iat_min",
        "fwd_iat_total", "fwd_iat_mean", "fwd_iat_std", "fwd_iat_max", "fwd_iat_min",
        "bwd_iat_total", "bwd_iat_mean", "bwd_iat_std", "bwd_iat_max", "bwd_iat_min",
        "fwd_psh_flags", "bwd_psh_flags", "fwd_urg_flags", "bwd_urg_flags",
        "fwd_header_len", "bwd_header_len", "fwd_packets_per_sec", "bwd_packets_per_sec",
        "pkt_len_min", "pkt_len_max", "pkt_len_mean", "pkt_len_std", "pkt_len_variance",
        "fin_flag_count", "syn_flag_count", "rst_flag_count", "psh_flag_count",
        "ack_flag_count", "urg_flag_count", "cwe_flag_count", "ece_flag_count",
        "down_up_ratio", "avg_packet_size", "avg_fwd_segment_size", "avg_bwd_segment_size",
        "fwd_bulk_rate_avg", "fwd_bulk_size_avg", "fwd_bulk_packets_avg",
        "bwd_bulk_rate_avg", "bwd_bulk_size_avg", "bwd_bulk_packets_avg",
        "subflow_fwd_packets", "subflow_fwd_bytes", "subflow_bwd_packets", "subflow_bwd_bytes",
        "init_fwd_win_bytes", "init_bwd_win_bytes", "act_data_pkt_fwd", "min_seg_size_fwd",
        "active_mean", "active_std", "active_max", "active_min",
        "idle_mean", "idle_std", "idle_max", "idle_min"
      ]
      skip_header => true
    }

    # Convert all numeric fields
    mutate {
      convert => {
        "duration" => "float"
        "total_fwd_packets" => "integer"
        "total_bwd_packets" => "integer"
        "total_fwd_bytes" => "integer"
        "total_bwd_bytes" => "integer"
        "flow_bytes_per_sec" => "float"
        "flow_packets_per_sec" => "float"
        "syn_flag_count" => "integer"
        "fin_flag_count" => "integer"
        "rst_flag_count" => "integer"
        "psh_flag_count" => "integer"
        "ack_flag_count" => "integer"
        "urg_flag_count" => "integer"
        "avg_packet_size" => "float"
        "down_up_ratio" => "float"
      }
    }

    # Calculate derived metrics
    ruby {
      code => "
        # Total packets
        fwd = event.get('total_fwd_packets').to_i
        bwd = event.get('total_bwd_packets').to_i
        event.set('total_packets', fwd + bwd)

        # Total bytes
        fwd_bytes = event.get('total_fwd_bytes').to_i
        bwd_bytes = event.get('total_bwd_bytes').to_i
        event.set('total_bytes', fwd_bytes + bwd_bytes)

        # Bidirectional ratio
        if bwd > 0
          event.set('fwd_bwd_packet_ratio', fwd.to_f / bwd)
        else
          event.set('fwd_bwd_packet_ratio', 0)
        end

        # Total TCP flags
        syn = event.get('syn_flag_count').to_i
        fin = event.get('fin_flag_count').to_i
        rst = event.get('rst_flag_count').to_i
        event.set('total_tcp_flags', syn + fin + rst)

        # Categorize flow type based on SYN flags
        if syn > 0 and fin == 0 and rst == 0
          event.set('flow_type', 'incomplete')
        elsif syn > 0 and fin > 0
          event.set('flow_type', 'complete')
        elsif rst > 0
          event.set('flow_type', 'reset')
        else
          event.set('flow_type', 'unknown')
        end
      "
    }

    # Categorize by traffic volume
    if [total_bytes] {
      if [total_bytes] > 10000000 {
        mutate { add_field => { "traffic_category" => "high" } }
      } else if [total_bytes] > 1000000 {
        mutate { add_field => { "traffic_category" => "medium" } }
      } else {
        mutate { add_field => { "traffic_category" => "low" } }
      }
    }

    # Add standard fields
    mutate {
      add_field => { "event.kind" => "metric" }
      add_field => { "event.category" => "network" }
      add_field => { "event.type" => "info" }
      add_field => { "event.dataset" => "hybrid_ids.features" }
    }
  }
}

output {
  if [type] == "network_features" {
    # Send to Elasticsearch
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "hybrid-ids-network-features-%{+YYYY.MM.dd}"
      document_type => "_doc"
    }
  }
}
