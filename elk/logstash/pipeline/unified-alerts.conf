# Logstash Pipeline for Unified Hybrid IDS Alerts
# Processes alerts from both NIDS and HIDS through the Unified Alert Manager

input {
  # Receive unified alerts from Alert Manager via TCP
  tcp {
    port => 5044
    codec => json_lines
    type => "unified_alert"
    tags => ["hybrid_ids", "unified"]
  }

  # Alternative: Read from file
  file {
    path => "/usr/share/logstash/data/alerts/unified_alerts.jsonl"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json_lines
    type => "unified_alert"
    tags => ["hybrid_ids", "unified", "file"]
  }

  # ZMQ input for real-time alerts (requires logstash-input-zeromq plugin)
  # zeromq {
  #   topology => "sub"
  #   address => "tcp://hybrid-ids:5558"
  #   type => "unified_alert"
  #   tags => ["hybrid_ids", "unified", "zmq"]
  # }
}

filter {
  # Parse @timestamp if not already set
  if ![timestamp] {
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  } else {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }

  # Add geo IP data for network-related alerts
  if [metadata][src_ip] {
    geoip {
      source => "[metadata][src_ip]"
      target => "[metadata][geoip_src]"
      fields => ["city_name", "country_name", "country_code2", "location"]
    }
  }

  if [metadata][dst_ip] {
    geoip {
      source => "[metadata][dst_ip]"
      target => "[metadata][geoip_dst]"
      fields => ["city_name", "country_name", "country_code2", "location"]
    }
  }

  # Enrich with DNS lookups (optional, can be slow)
  # if [metadata][src_ip] {
  #   dns {
  #     reverse => [ "[metadata][src_ip]" ]
  #     action => "replace"
  #     add_field => { "[metadata][src_hostname]" => "%{[metadata][src_ip]}" }
  #   }
  # }

  # Categorize alerts by source
  if [source] {
    mutate {
      add_field => { "ids_type" => "%{source}" }
    }

    # Split source to get main category
    ruby {
      code => '
        source = event.get("source")
        if source
          parts = source.split("_")
          event.set("ids_category", parts[0])
          event.set("ids_subcategory", parts[1]) if parts.length > 1
        end
      '
    }
  }

  # Add severity numeric value for sorting
  if [severity] {
    translate {
      field => "severity"
      destination => "severity_num"
      dictionary => {
        "INFO" => "1"
        "LOW" => "2"
        "MEDIUM" => "3"
        "HIGH" => "4"
        "CRITICAL" => "5"
      }
      fallback => "3"
    }

    mutate {
      convert => { "severity_num" => "integer" }
    }
  }

  # Extract MITRE ATT&CK information if present
  if [metadata][mitre_attack] {
    mutate {
      add_field => { "mitre_technique" => "%{[metadata][mitre_attack]}" }
    }

    # Add MITRE tactic based on technique (simplified mapping)
    translate {
      field => "mitre_technique"
      destination => "mitre_tactic"
      dictionary_path => "/etc/logstash/mitre_tactics.yaml"
      fallback => "unknown"
    }
  }

  # Tag correlated alerts
  if [source] == "correlation" {
    mutate {
      add_tag => ["correlated", "high_priority"]
    }
  }

  # Tag critical severity alerts
  if [severity] == "CRITICAL" {
    mutate {
      add_tag => ["critical", "immediate_action"]
    }
  }

  # Add alert age (time since generation)
  ruby {
    code => '
      if event.get("@timestamp")
        age_seconds = Time.now - event.get("@timestamp").time
        event.set("alert_age_seconds", age_seconds.to_i)
        event.set("alert_age_minutes", (age_seconds / 60).to_i)
      end
    '
  }

  # Clean up and normalize field names
  mutate {
    rename => {
      "alert_id" => "alertId"
      "alert_age_seconds" => "alertAge"
    }
    remove_field => ["@version", "host", "path"]
  }
}

output {
  # Output to Elasticsearch with index rotation
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "hybrid-ids-alerts-%{+YYYY.MM.dd}"

    # Template management
    template_name => "hybrid-ids-alerts"
    template_overwrite => true

    # Document ID to prevent duplicates
    document_id => "%{alertId}"

    # Performance tuning
    flush_size => 100
    idle_flush_time => 10
  }

  # Separate index for critical alerts
  if "critical" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "hybrid-ids-critical-%{+YYYY.MM.dd}"
      document_id => "%{alertId}"
    }
  }

  # Separate index for correlated alerts (APT indicators)
  if "correlated" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "hybrid-ids-correlated-%{+YYYY.MM.dd}"
      document_id => "%{alertId}"
    }
  }

  # Output to stdout for debugging (disable in production)
  # stdout {
  #   codec => rubydebug {
  #     metadata => true
  #   }
  # }

  # Optional: Forward to SIEM
  # syslog {
  #   host => "siem-server"
  #   port => 514
  #   protocol => "tcp"
  #   codec => json_lines
  # }
}
